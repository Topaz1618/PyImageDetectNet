from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad
import base64

# Replace with your secret key (use the same key as in the frontend)
secret_key = b'YourSecretKey123'  # Ensure it's in bytes format


# Function to encrypt data with padding and IV included in the result
def encrypt_data(data):
    cipher = AES.new(secret_key, AES.MODE_CBC)
    iv = cipher.iv  # Get the IV generated by PyCryptodome
    padded_data = pad(data.encode('utf-8'), AES.block_size)
    ct_bytes = cipher.encrypt(padded_data)

    # Combine IV and ciphertext and encode as Base64
    iv_and_ciphertext = iv + ct_bytes
    return base64.b64encode(iv_and_ciphertext).decode('utf-8')


def decrypt_data(encrypted_text):
    encrypted_text = base64.b64decode(encrypted_text)

    cipher = AES.new(secret_key, AES.MODE_CBC, encrypted_text[:AES.block_size])
    decrypted = cipher.decrypt(encrypted_text[AES.block_size:])
    # Strip PKCS7 padding manually

    padding_length = decrypted[-1]
    decrypted = decrypted[:-padding_length]
    return decrypted


def read_file_chunk(file_path, chunk_size):
    with open(file_path, 'rb') as file:
        with open("output.png", 'wb') as output:
            while True:
                chunk = file.read()
                if not chunk:
                    break
                # 处理读取的数据，这里可以根据需求进行操作
                decrypted_data = decrypt_data(chunk)
                print(len(decrypted_data), decrypted_data)
                output.write(decrypted_data)


if __name__ == "__main__":
    # Example usage:
    encrypted_data_from_frontend = b"R3Eb3O09zTtD4ys302xzjkko4uu5ajA2kbKS6qyNuWc="  # Replace with the actual encrypted data
    decrypted_data = decrypt_data(encrypted_data_from_frontend)
    print(decrypted_data)
    #
    #
    #
    ## 指定文件路径和要读取的大小（以字节为单位）
    # file_path = '../upload/test_image.png'
    # chunk_size = 128  # 例如，每次读取 1024 字节
    #
    # read_file_chunk(file_path, chunk_size)
